<!DOCTYPE html>
<html lang="en" dir="ltr">

<head>
	<link rel="stylesheet" href="CSS/style.css">
	<title>Graph it - WebGL</title>
</head>

<body>
<textarea id="functions">(Math.sin(time), Math.cos(time))
x=Math.sin(time)
y=Math.cos(time)
(Math.PI, 0)
(Math.E, 0)</textarea>

	<script src="https://code.jquery.com/jquery-3.3.1.js" integrity="sha256-2Kok7MbOyxpgUVvAk/HJ2jigOSYS2auK4Pfzbm7uH60="
	 crossorigin="anonymous"></script>
	<script src="JS/Math/Vector2.js"></script>
	<script src="JS/Math/Matrix3.js"></script>
	<script src="JS/Application/Application.js"></script>
	<script src="JS/Graphics/Color.js"></script>
	<script src="JS/Graphics/Canvas.js"></script>

	<script type="glsl" id="VERT_SHADER">
		attribute vec2 aPos; 
		attribute vec4 aColor; 
		
		uniform mat3 uMatrix;

		varying lowp vec4 vColor;
		
		void main(void) {
			vec2 position = (uMatrix * vec3(aPos.x, aPos.y, 1)).xy;
			gl_Position = vec4(position.xy, 0.0, 1.0); 
			gl_PointSize = 4.0;
			vColor = aColor;
		}
	</script>

	<script type="glsl" id="FRAG_SHADER">
		varying lowp vec4 vColor;
		
		void main(void) {
			gl_FragColor = vColor;
		}
	</script>

	<script>
		$(document).ready(function () {
			let app = new Application(60, 60);
			let canvas = new Canvas('webgl', new Vector2(500, 500), null, true);
			let text = new Canvas('2d', new Vector2(500, 500), null, false);
			let functions = [];
			let time = 0;

			app.onStart = function () {
				canvas.setupShaders(document.getElementById("VERT_SHADER").textContent, document.getElementById("FRAG_SHADER").textContent);
				canvas.setBackground(new Color(0.952, 0.952, 0.952, 1));
				canvas.setMargin(new Vector2(200, 0));
				canvas.fullscreen(true);

				text.setMargin(new Vector2(200, 0));
				text.fullscreen(true);

				let minDim = Math.min((canvas.dimensions.x - canvas.margin.x), (canvas.dimensions.y - canvas.margin.y));
				let xScale = (canvas.dimensions.y - canvas.margin.y) / (minDim * 10);
				let yScale = (canvas.dimensions.x - canvas.margin.x) / (minDim * 10);

				canvas.scale = new Vector2(xScale, yScale);

				Canvas.registerKey(16, null, null);

				function checkFunctions() {
					functions = [];
					var functionStrings = $('#functions').val().split('\n');
					for (let i = 0; i < functionStrings.length; i++) {
						if (functionStrings[i].length > 0) {
							try {
								let index = functions.length;
								let string = functionStrings[i].trim();
								let type = string[0];
								let func;
								if (type == 'x' || type == 'y')
									func = 'let funcS = function(x, y) { return ' + string.substring(2, string.length) + '; }; functions[parseInt(' + index + ')] = {type: "' + type + '", f: funcS};';
								else if (type == '(' && string[string.length - 1] == ')')
									func = 'let funcS = function(x, y) { return new Vector2(' + string.substring(1, string.length - 1) + '); }; functions[parseInt(' + index + ')] = {type: "' + type + '", f: funcS};';
								try {
									eval(func);
								} catch {

								}
							} catch {
								console.log('Invalid function');
							}
						}
					}
				}

				$('#functions').on('input', checkFunctions);
				$('#functions').ready(checkFunctions);
			};

			app.onUpdate = function () {
				let mouseDelta = Canvas.mouseDelta();
				let scrollDelta = Canvas.scrollDelta();

				if (Canvas.mouseDown) {
					canvas.position.x += ((mouseDelta.x * 2) / (canvas.dimensions.x - canvas.margin.x) * (1 / canvas.scale.x));
					canvas.position.y -= ((mouseDelta.y * 2) / (canvas.dimensions.y - canvas.margin.y) * (1 / canvas.scale.y));
				}

				if (Math.abs(scrollDelta.x) + Math.abs(scrollDelta.y) > 0) {
					let deltaX, deltaY;
					if (Canvas.getKeyDown(16) == true) {
						deltaX = scrollDelta.x * scrollDelta.x * scrollDelta.x;
						deltaY = scrollDelta.y * scrollDelta.y * scrollDelta.y;
					} else {
						deltaX = (scrollDelta.x + scrollDelta.y) * Math.min(canvas.scale.x * canvas.scale.x * 0.5, canvas.scale.y * canvas.scale.y * 0.5) * 50;
						deltaY = deltaX;
					}

					deltaX = Math.min(Math.max(0.01, Math.abs(deltaX)), 50) * Math.sign(deltaX);
					deltaY = Math.min(Math.max(0.01, Math.abs(deltaY)), 50) * Math.sign(deltaY);

					canvas.scale.x += (deltaX / ((canvas.dimensions.x - canvas.margin.x)));
					canvas.scale.y += (deltaY / ((canvas.dimensions.y - canvas.margin.y)));

					canvas.scale.x = Math.min(Math.max(0.0001, canvas.scale.x), 100);
					canvas.scale.y = Math.min(Math.max(0.0001, canvas.scale.y), 100);
				}

				let matrix = Matrix3.multiply(Matrix3.scaling(canvas.scale.x, canvas.scale.y), Matrix3.translation(canvas.position.x, canvas.position.y));

				let centerX = matrix[6] / matrix[0];
				let centerY = matrix[7] / matrix[4];

				let oneScaledX = 1 / matrix[0];
				let oneScaledY = 1 / matrix[4];

				canvas.flush();
				if (functions.length > 0) {
					for (let i = 0; i < functions.length; i++) {
						if (functions[i].type == 'x') {
							try {
								canvas.renderLineY(-centerY - oneScaledY, -centerY + oneScaledY, 1000, functions[i].f, new Color(1, 0, 0, 1));
								canvas.flush('LINE', true);
							} catch { }
						} else if (functions[i].type == 'y') {
							try {
								canvas.renderLineX(-centerX - oneScaledX, -centerX + oneScaledX, 1000, functions[i].f, new Color(0, 1, 0, 1));
								canvas.flush('LINE', true);
							} catch { }
						} else if (functions[i].type == '(') {
							try {
								canvas.renderPoint(functions[i].f, new Color(0, 0, 1, 1));
								canvas.flush('POINT', true);
							} catch { }
						}
					}
				}

				text.position = canvas.position;
				text.scale = canvas.scale;

				canvas.renderLineX(-centerX - oneScaledX, -centerX + oneScaledX, 1, function (x) {
					return 0;
				}, new Color(0, 0, 0, 1));
				canvas.flush('LINE', true);

				canvas.renderLineY(-centerY - oneScaledY, -centerY + oneScaledY, 1, function (y) {
					return 0;
				}, new Color(0, 0, 0, 1));
				canvas.flush('LINE', true);

				let min = Math.min(oneScaledX, oneScaledY);
				let size = Math.max(Math.round(min), 10);
				while (size % 10 != 0) {
					size--;
				}

				while (size > min * 0.2) {
					size *= 0.1;
				}

				if (size > 1) {
					centerX = Math.round(centerX);
					while (centerX % size != 0) {
						centerX--;
					}

					centerY = Math.round(centerY);
					while (centerY % size != 0) {
						centerY--;
					}
				}

				canvas.renderGridX(Math.round((-centerX)), -centerY - oneScaledY, -centerY + oneScaledY, size, oneScaledX);
				canvas.flush('LINE', true);

				canvas.renderGridY(Math.round((-centerY)), -centerX - oneScaledX, -centerX + oneScaledX, size, oneScaledY);
				canvas.flush('LINE', true);

				text.renderTextX(Math.round((-centerX)), -centerY - oneScaledY, -centerY + oneScaledY, size, oneScaledX);
				text.renderTextY(Math.round((-centerY)), -centerX - oneScaledX, -centerX + oneScaledX, size, oneScaledY);
				text.flush2d();

				time += 1 / 60;
			}

			app.start();
		});
	</script>
</body>

</html>